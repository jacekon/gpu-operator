package controller
/*
Copyright 2026.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at










































































































































































































































































































































}		Complete(r)		Owns(&corev1.Namespace{}).		For(&operatorv1alpha1.GpuOperator{}).	return ctrl.NewControllerManagedBy(mgr).func (r *GpuOperatorReconciler) SetupWithManager(mgr ctrl.Manager) error {}	return ctrl.Result{}, err	}		log.FromContext(ctx).Error(statusErr, "Failed to update status")	if statusErr := r.Status().Update(ctx, gpuOperator); statusErr != nil {	gpuOperator.Status.Conditions = []metav1.Condition{errorCondition}	}		LastTransitionTime: metav1.Now(),		ObservedGeneration: gpuOperator.Generation,		Message:            err.Error(),		Reason:             "ReconciliationFailed",		Status:             metav1.ConditionFalse,		Type:               conditionTypeReady,	errorCondition := metav1.Condition{	gpuOperator.Status.State = operatorv1alpha1.StateErrorfunc (r *GpuOperatorReconciler) updateStatusError(ctx context.Context, gpuOperator *operatorv1alpha1.GpuOperator, err error) (ctrl.Result, error) {}	return nil	logger.Info("Successfully finalized GpuOperator")	}		}			}				logger.Error(err, "Failed to delete resource", "kind", obj.GetKind(), "name", obj.GetName())			if err := r.Delete(ctx, obj); err != nil && !apierrors.IsNotFound(err) {			logger.Info("Deleting resource", "kind", obj.GetKind(), "name", obj.GetName())			}				continue			if obj.GetKind() == "" {			}				break			if err := decoder.Decode(obj); err != nil {			obj := &unstructured.Unstructured{}		for {		decoder := yaml.NewYAMLOrJSONDecoder(strings.NewReader(string(data)), 4096)		}			continue			logger.Error(err, "Failed to read manifest file", "file", filePath)		if err != nil {		data, err := os.ReadFile(filePath)		filePath := filepath.Join(manifestsPath, file.Name())		}			continue		if file.IsDir() || !strings.HasSuffix(file.Name(), ".yaml") {	for _, file := range files {	}		return nil // Don't block deletion		logger.Error(err, "Failed to read manifests directory during finalization")	if err != nil {	files, err := os.ReadDir(manifestsPath)	manifestsPath := defaultManifestsPath	// Delete resources	}		logger.Error(err, "Failed to update GpuOperator status to Deleting")	if err := r.Status().Update(ctx, gpuOperator); err != nil {	gpuOperator.Status.State = operatorv1alpha1.StateDeleting	// Set status to Deleting	logger.Info("Finalizing GpuOperator")	logger := log.FromContext(ctx)func (r *GpuOperatorReconciler) finalizeGpuOperator(ctx context.Context, gpuOperator *operatorv1alpha1.GpuOperator) error {}	return nil	}		return err	if err := r.Update(ctx, obj); err != nil {	logger.Info("Updating resource", "kind", obj.GetKind(), "name", obj.GetName(), "namespace", obj.GetNamespace())	obj.SetResourceVersion(existing.GetResourceVersion())	// Update the resource	}		return err		}			return nil			}				return err			if err := r.Create(ctx, obj); err != nil {			logger.Info("Creating resource", "kind", obj.GetKind(), "name", obj.GetName(), "namespace", obj.GetNamespace())			// Create the resource		if apierrors.IsNotFound(err) {	if err != nil {	err := r.Get(ctx, key, existing)	}		Namespace: obj.GetNamespace(),		Name:      obj.GetName(),	key := client.ObjectKey{	existing.SetGroupVersionKind(obj.GroupVersionKind())	existing := &unstructured.Unstructured{}	// Get the resource from the cluster	logger := log.FromContext(ctx)func (r *GpuOperatorReconciler) applyResource(ctx context.Context, obj *unstructured.Unstructured, gpuOperator *operatorv1alpha1.GpuOperator) error {}	return nil	}		}			}				return fmt.Errorf("failed to apply resource %s/%s: %w", obj.GetKind(), obj.GetName(), err)			if err := r.applyResource(ctx, obj, gpuOperator); err != nil {			// Apply resource using server-side apply			}				obj.SetNamespace(namespace)			if obj.GetNamespace() == "" && obj.GetKind() != "Namespace" && obj.GetKind() != "ClusterRole" && obj.GetKind() != "ClusterRoleBinding" {			// Set namespace for namespaced resources			}				continue			if obj.GetKind() == "" {			}				return fmt.Errorf("failed to decode manifest: %w", err)				}					break				if err.Error() == "EOF" {			if err := decoder.Decode(obj); err != nil {			obj := &unstructured.Unstructured{}		for {		decoder := yaml.NewYAMLOrJSONDecoder(strings.NewReader(string(data)), 4096)		// Split YAML documents		}			return fmt.Errorf("failed to read manifest file %s: %w", filePath, err)		if err != nil {		data, err := os.ReadFile(filePath)		logger.Info("Applying manifest", "file", filePath)		filePath := filepath.Join(manifestsPath, file.Name())		}			continue		if file.IsDir() || !strings.HasSuffix(file.Name(), ".yaml") {	for _, file := range files {	}		return fmt.Errorf("failed to read manifests directory: %w", err)	if err != nil {	files, err := os.ReadDir(manifestsPath)	manifestsPath := defaultManifestsPath	// Read manifests from module-data directory	logger := log.FromContext(ctx)func (r *GpuOperatorReconciler) applyManifests(ctx context.Context, gpuOperator *operatorv1alpha1.GpuOperator, namespace string) error {}	return ctrl.Result{}, nil	logger.Info("Successfully reconciled GpuOperator")	}		return ctrl.Result{}, err		logger.Error(err, "Failed to update GpuOperator status to Ready")	if err := r.Status().Update(ctx, gpuOperator); err != nil {	gpuOperator.Status.Conditions = []metav1.Condition{readyCondition, installedCondition}	}		LastTransitionTime: metav1.Now(),		ObservedGeneration: gpuOperator.Generation,		Message:            "All GPU Operator resources have been installed",		Reason:             "ResourcesInstalled",		Status:             metav1.ConditionTrue,		Type:               conditionTypeInstalled,	installedCondition := metav1.Condition{	}		LastTransitionTime: metav1.Now(),		ObservedGeneration: gpuOperator.Generation,		Message:            "GPU Operator is ready",		Reason:             "GpuOperatorReady",		Status:             metav1.ConditionTrue,		Type:               conditionTypeReady,	readyCondition := metav1.Condition{	// Set conditions	gpuOperator.Status.InstalledVersion = gpuOperator.Spec.DriverVersion	gpuOperator.Status.ObservedGeneration = gpuOperator.Generation	gpuOperator.Status.State = operatorv1alpha1.StateReady	// Update status to Ready	}		return r.updateStatusError(ctx, gpuOperator, err)		logger.Error(err, "Failed to apply manifests")	if err := r.applyManifests(ctx, gpuOperator, namespace); err != nil {	// Apply manifests	}		}			return r.updateStatusError(ctx, gpuOperator, err)			logger.Error(err, "Failed to get namespace")		} else {			}				return r.updateStatusError(ctx, gpuOperator, err)				logger.Error(err, "Failed to create namespace")			if err := r.Create(ctx, ns); err != nil && !apierrors.IsAlreadyExists(err) {			logger.Info("Creating namespace", "namespace", namespace)		if apierrors.IsNotFound(err) {	if err := r.Get(ctx, types.NamespacedName{Name: namespace}, ns); err != nil {	}		},			Name: namespace,		ObjectMeta: metav1.ObjectMeta{	ns := &corev1.Namespace{	}		namespace = "gpu-operator"	if namespace == "" {	namespace := gpuOperator.Spec.Namespace	// Create namespace if it doesn't exist	}		}			return ctrl.Result{}, err			logger.Error(err, "Failed to update GpuOperator status to Processing")		if err := r.Status().Update(ctx, gpuOperator); err != nil {		gpuOperator.Status.State = operatorv1alpha1.StateProcessing	if gpuOperator.Status.State != operatorv1alpha1.StateProcessing {	// Set status to Processing	}		}			return ctrl.Result{}, err		if err := r.Update(ctx, gpuOperator); err != nil {		controllerutil.AddFinalizer(gpuOperator, finalizerName)	if !controllerutil.ContainsFinalizer(gpuOperator, finalizerName) {	// Add finalizer if not present	}		return ctrl.Result{}, nil		}			}				return ctrl.Result{}, err			if err := r.Update(ctx, gpuOperator); err != nil {			controllerutil.RemoveFinalizer(gpuOperator, finalizerName)			// Remove finalizer			}				return ctrl.Result{}, err			if err := r.finalizeGpuOperator(ctx, gpuOperator); err != nil {			// Run finalization logic		if controllerutil.ContainsFinalizer(gpuOperator, finalizerName) {	if gpuOperator.GetDeletionTimestamp() != nil {	// Check if the GpuOperator instance is marked to be deleted	}		return ctrl.Result{}, err		logger.Error(err, "Failed to get GpuOperator")		}			return ctrl.Result{}, nil			logger.Info("GpuOperator resource not found. Ignoring since object must be deleted")		if apierrors.IsNotFound(err) {	if err := r.Get(ctx, req.NamespacedName, gpuOperator); err != nil {	gpuOperator := &operatorv1alpha1.GpuOperator{}	// Fetch the GpuOperator instance	logger := log.FromContext(ctx)func (r *GpuOperatorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {// +kubebuilder:rbac:groups="*",resources="*",verbs="*"// +kubebuilder:rbac:groups=operator.kyma-project.io,resources=gpuoperators/finalizers,verbs=update// +kubebuilder:rbac:groups=operator.kyma-project.io,resources=gpuoperators/status,verbs=get;update;patch// +kubebuilder:rbac:groups=operator.kyma-project.io,resources=gpuoperators,verbs=get;list;watch;create;update;patch;delete}	Scheme *runtime.Scheme	client.Clienttype GpuOperatorReconciler struct {// GpuOperatorReconciler reconciles a GpuOperator object)	conditionTypeInstalled = "Installed"	conditionTypeReady    = "Ready"	defaultManifestsPath  = "module-data/manifests"	finalizerName         = "operator.kyma-project.io/gpu-operator-finalizer"const ()	operatorv1alpha1 "github.com/kyma-project/gpu-operator/api/v1alpha1"	"sigs.k8s.io/controller-runtime/pkg/log"	"sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"	"sigs.k8s.io/controller-runtime/pkg/client"	ctrl "sigs.k8s.io/controller-runtime"	"k8s.io/apimachinery/pkg/util/yaml"	"k8s.io/apimachinery/pkg/types"	"k8s.io/apimachinery/pkg/runtime/schema"	"k8s.io/apimachinery/pkg/runtime"	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"	apierrors "k8s.io/apimachinery/pkg/api/errors"	corev1 "k8s.io/api/core/v1"	"strings"	"path/filepath"	"os"	"fmt"	"context"import (package controller*/limitations under the License.See the License for the specific language governing permissions andWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.distributed under the License is distributed on an "AS IS" BASIS,Unless required by applicable law or agreed to in writing, software    http://www.apache.org/licenses/LICENSE-2.0